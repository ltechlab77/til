## 継承
既存クラスの機能を引き継いで、新しいクラスを作る仕組み  

例  
```java
class Animal {
    void speak() {
        System.out.println("鳴く");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("ワンワン");
    }
}


Dog dog = new Dog();
dog.speak(); // 親クラスのメソッド
dog.bark();  // 子クラス独自
```

<br>

```java
public class クラス名 extends 元となるクラス名 {
    親クラスとの差分
}
```

1つのクラスをベースに子クラス、孫クラスと定義していくことは可能  
<u>複数の親クラスを使って１つの子クラスを定義する(**多重継承**)はできない</u>

### オーバーライド
親クラスのメソッドを、子クラスで“上書き”する
```java
//親クラス
class 勇者 {
    int 攻撃力() {
        return 10; // 基本攻撃力
    }
}
//子クラス
class 剣士勇者 extends 勇者 {
    @Override
    int 攻撃力() {
        return 20; // 剣士の攻撃力
    }
}
//子クラス
class 魔法使い勇者 extends 勇者 {
    @Override
    int 攻撃力() {
        return 15; // 魔法ダメージ込み
    }
}

勇者 a = new 剣士勇者();
勇者 b = new 魔法使い勇者();

System.out.println(a.攻撃力()); // 20
System.out.println(b.攻撃力()); // 15
```

`@Override`アノテーション

- ついてなくてもオーバーライドは可能
- つけることによってうっかりミスを事前に防止できる

<br>
宣言に`final`がつけられているクラスは継承できない  

<br>

 `super`  
親クラスを参照するためのキーワード  
継承（extends）しているクラス内でのみ使用できる。
- 親クラスのメソッドを呼ぶ
- 親クラスのメソッドを呼ぶ

super を付けないと 自分自身のメソッドが呼ばれる  
誤ると無限再帰（StackOverflowError）になる

### abstract クラス
共通の実装を持ちつつ、未完成な設計を強制するクラス  
new できない  
継承（extends）して使う  
抽象メソッドを持てる  
```java
abstract class 勇者 {
    abstract int 攻撃力();

    int HP() {
        return 100;
    }
}

class 剣士勇者 extends 勇者 {
    @Override
    int 攻撃力() {
        return 20;
    }
}
```
抽象メソッドを1つでも持つとクラスも abstract
多重継承は不可（extends は1つだけ）

### interface
「クラスが守るべきルール（契約）」を定義するもの。  

実装は基本的に持たない  
クラスは implements で実装  
多重実装が可能  
```java
interface 勇者 {
    int 攻撃力();
}

class 魔法使い勇者 implements 勇者 {
    @Override
    public int 攻撃力() {
        return 15;
    }
}
```
特別に多重実装できる
クラスの型として使える
実装を持たない設計に向いている