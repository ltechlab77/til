## 多態性（ポリモーフィズム）
親クラス型で扱っているのに、中身（子クラス）によって振る舞いが変わること

```java
public abstract class Monster{
    public void run() {
        System.out.println("モンスターは逃げ出した");
    }
}
```
```java
public class Slime extends Monster{
    public void run(){
        System.out.println("スライムはサササっと逃げ出した");
    }
}
```
```java
public class Main {
    public static void main(String[] args){
    Slime s = new Slime();
    Monster m = new Slime();
    }
}
```
```
スライムはサササっと逃げ出した
スライムはサササっと逃げ出した
```
なぜこうなるのか
```java
Monster m = new Slime();
m.run();
```

型：Monster  
実体：Slime  
なので、実体（Slime）の run() が呼ばれる  
これが ポリモーフィズム（動的バインディング）


### 多態性のメリット
同一視して配列利用
```java
public class Main {
    public static void main(String[] args){
        Hero h1 =new Hero();
        Hero h2 =new Hero();
        Thief t1 =new thief();
        Wizard w1 =new Wizard();
        Wizard w2 =new Wizard();
        

        h1.hp += 50;
        h2.hp += 50;
        t1.hp += 50;
        w1.hp += 50;
        w2.hp += 50;
    }
}
```
- コード重複が多い
- 将来的に修正が必要の可能性

```java
//characterクラス割愛
public class Main {
    public static void main(String[] args){
        Character[] c = new Character[5];
        c[0] = new Hero();
        c[1] = new Hero();
        c[2] = new Thief();
        c[3] = new Wizard();
        c[4] = new Wizard();

        for (character ch : c){
            ch.hp += 50
        }
    }
}
```
- ループを回して一括処理ができる


// やっていることはわかるがそれが多態性であることがわからない   26/01/29  
//なんとなくわかったきがする　26/01/29