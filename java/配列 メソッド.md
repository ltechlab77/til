# 配列　
同じ型のデータを複数まとめて扱うためのデータ構造

配列の宣言  
`int[] scores`  

要素の作成と代入  
 `scores = new int[5]`
「int型の」要素を5個作り配列変数soresに代入  

配列の宣言と作成を同時に
`int[] scores = new int [5]`  

配列の長さ
`配列変数名.length`  

- 配列の初期化  

``` java  
//1つずつ代入
scores[0] = 80;
scores[1] = 90;
scores[2] = 70;  
//まとめて初期化
int[] scores = {80, 90, 70, 85, 60};
```  

何もしなければ自動的に０、false、nullになる  

配列の作成から初期化までの省略

``` java
int [] scores1 = new int[] {2,3,4,5,6,};
int [] scores2 = {2,3,4,5,6};
```

### - 配列とfor文  

①　ループによる全要素の利用  
②　ループによる集計  
③　添え字に対応した情報の利用  

①forループで配列を回す  
`for (int i = 0; i < 配列変数名.length; i++){
    配列変数名[i]を使った処理
}`  

②ループによる集計

```java
int[] scores = {80, 90, 70, 85, 60};

int sum = 0;
//合計
for (int i = 0; i < scores.length; i++) {
    sum += scores[i];
}
System.out.println(sum); // 385

//平均
for (int i = 0; i < scores.length; i++) {
    sum += scores[i];
}
double avg = (double) sum / scores.length;
System.out.println(avg); // 77.0


//最大値
int max = scores[0];
for (int i = 1; i < scores.length; i++) {
    if (scores[i] > max) {
        max = scores[i];
    }
}
System.out.println(max); // 90

//最小
int min = scores[0];
for (int i = 1; i < scores.length; i++) {
    if (scores[i] < min) {
        min = scores[i];
    }
}
System.out.println(min); // 60

```

- 拡張for文（for-each文）  
配列の全要素を先頭から順番に取り出す  
`for 要素の型　任意の変数名 : 配列変数名 {処理}`

```java
int[] scores = {80, 90, 70, 85};
//通常for文
for (int i = 0; i < scores.length; i++) {
    System.out.println(scores[i]);
}
//拡張for文
for (int score : scores) {
    System.out.println(score);
}
```

# メソッド  

処理をひとまとめにしたもの、何度も使える命令の塊  

メリット

- 全体を把握しやすくなる
- 修正範囲を限定できる
- 同じ処理を1つにまとめることで作業効率が上がる

- メソッドの定義

```java
public static void メソッド名(引数) {
    処理;
}
```

サンプルコード

```java
public static void hello() {
    System.out.println("こんにちは");
}
```

- メソッドの呼び出し  
`メソッド名()`  
サンプルの呼び出し  
`hello();`

- 引数について  

```java
public static void greet(String name) {
    System.out.println("こんにちは、" + name + "さん");
}
//呼び出し
greet("太郎");
```
引数は複数でもOK  

``` java
public static void add(int x, int y){
    int ans = x + y;
    Systesm.out.println(x + "+" + y + "=" + ans);
}

add(100, 20)
add(100, 50)
```

- 戻り値ついて  
メソッドの処理結果として呼び出しもとに返す値

```java
戻り値の型 メソッド名(引数) {
    return 値;
}

public static int add(int a, int b) {
    return a + b;
}

int result = add(3, 5);
System.out.println(result); // 8
```
return分の後に処理はかけない  
戻り値は一致する  
条件分岐と戻り値　すべてのルートに return が必要  
エラー文

```java
public static int check(int n) {
    if (n > 0) {
        return 1;
    }
    // return がない
}
```
正しい例

```java
public static int check(int n) {
    if (n > 0) {
        return 1;
    } else {
        return -1;
    }
}
```

- オーバーロード  
同じメソッド名で引数が違うメソッドを複数作ることができる  
条件  
メソッド名が同じ  
引数の型、または数または順番が違う
```java
public class Sample {

    public static void print(int x) {
        System.out.println(x);
    }

    public static void print(String s) {
        System.out.println(s);
    }

    public static void print(int x, int y) {
        System.out.println(x + ", " + y);
    }
}

print(10);          // int版が呼ばれる
print("Hello");     // String版が呼ばれる
print(3, 5);        // int,int版が呼ばれる

```

出欠管理
```java
import java.util.Scanner;

public class AttendanceSystem {
    static String[] students = new String[30]; //30人まで保存可能
    static boolean[] attendance =new boolean[30];//30個のtrue or falseを保存する配列
    static int count = 0;

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);

        while (true){                                   //tureは常に真なので無限ループ
            showMenu();                                 //breakされるまでずっと繰り返す
            int choice = sc.nextInt();

            if (choice == 1){
                addStudent(sc);
            }else if (choice == 2){
                markAttendance(sc);
            }else if (choice == 3){
                showAll();
            }else if (choice == 0){
                System.out.println("終了します");
                break;
            }else {
                System.out.println("無効な選択です");
            }
        }
    }

    //メニューの表示
    static void showMenu() {
        System.out.println("--- 出欠管理システム ---");
        System.out.println("1: 生徒追加");
        System.out.println("2: 出欠登録");
        System.out.println("3: 一覧表示");
        System.out.println("0: 終了");
        System.out.println("選択: ");
    }

    //生徒追加
    static void addStudent(Scanner sc){
        if (count >= students.length){
            System.out.println("これ以上追加できません");
            return;
        }

        System.out.println("生徒名を入力: ");
        students[count] = sc.next();  //入力された名前を配列に入れる
        attendance[count] = false; //初期は欠席　
        count++;  //ここでカウントすることで名前の上書を防ぐ

        System.out.println("生徒を追加しました");
    }

    //出欠登録
    static void markAttendance(Scanner sc){
        showAll();
        System.out.println("番号を選択: ");
        int index = sc.nextInt();

        if (index < 0 || index >= count){
            System.out.println("番号が不正です");
            return;
        }

        System.out.println("出席なら1、欠席なら0: ");
        int input = sc.nextInt();
        attendance[index] = (input == 1);  //attendanceはboolean型だから1以外を入れてもfalse

        System.out.println("出席を登録しました");
    }

    //一覧表示
    static void showAll(){
        System.out.println("--- 一覧 ---");
        for (int i = 0; i < count; i++){
            String status = attendance[i] ? "出席" : "欠席";   //条件 ? 真 : 偽　　　もし attendance[i] が true なら "出席"、そうでなければ "欠席" を status に入れる
            System.out.println(i + ": " + students[i] + " - " + status);
        }
    }
}
```